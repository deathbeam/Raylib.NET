using System.Text;
using System.Text.RegularExpressions;
using CppAst;
using Microsoft.CodeAnalysis.CSharp;

namespace Bindgen;

public class Generator
{
    private const string Header = "// This file was generated by Bindgen, do not edit it manually.";
    private readonly GeneratorOptions options;

    private readonly string fileContent;
    private readonly HashSet<string> reservedKeywords = new HashSet<string>();
    private readonly Dictionary<string, Dictionary<string, string>> literalValues = new();

    public Generator(GeneratorOptions options)
    {
        this.options = options;
        fileContent = File.ReadAllText(options.FilePath);

        foreach (var keyword in SyntaxFacts.GetKeywordKinds())
        {
            reservedKeywords.Add(SyntaxFacts.GetText(keyword));
        }
    }

    public void Generate()
    {
        var preHeaderText = "";
        foreach (var include in options.Includes)
        {
            preHeaderText += $"#include <{include}>\n";
        }

        preHeaderText = preHeaderText.Trim();

        var parserOptions = new CppParserOptions
        {
            AdditionalArguments = { "-xc", "-std=gnu99" },
            PreHeaderText = string.IsNullOrEmpty(preHeaderText) ? null : preHeaderText,
            ParseAsCpp = false,
            ParseComments = true,
            ParseMacros = true,
        };

        parserOptions.SystemIncludeFolders.AddRange(options.SystemIncludeFolders);
        parserOptions.IncludeFolders.AddRange(options.IncludeFolders);
        parserOptions.Defines.AddRange(options.Defines);

        Console.WriteLine();
        Console.WriteLine($">>>>>>>> Parsing: {options.FilePath}");
        var ast = CppParser.Parse(fileContent, parserOptions);

        Console.WriteLine();
        Console.WriteLine($"> Diagnostics: {ast.Diagnostics.Messages.Count}");
        foreach (var message in ast.Diagnostics.Messages)
        {
            Console.WriteLine(message);
        }

        var types = new List<string>();
        var builder = new StringBuilder();

        builder.AppendLine(Header);
        builder.AppendLine("using System.Runtime.CompilerServices;");
        builder.AppendLine("using System.Runtime.InteropServices;");
        builder.AppendLine("using Bindgen.Interop;");

        foreach (var import in options.ExistingTypes.Values.Distinct())
        {
            builder.AppendLine($"using {import};");
        }

        builder.AppendLine();
        builder.AppendLine($"namespace {options.GeneratedNamespace};");
        builder.AppendLine();
        builder.AppendLine($"public static unsafe partial class {options.GeneratedClass}");
        builder.AppendLine("{");
        builder.AppendLine($"    public const string LIBRARY = \"{options.LibraryName}\";");

        Console.WriteLine();
        Console.WriteLine($"> Macros: {ast.Macros.Count}");
        foreach (var macro in ast.Macros)
        {
            if (!ShouldGenerate(macro.Span))
            {
                continue;
            }

            var name = GenerateConstant(macro, out var generated);
            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(generated))
            {
                continue;
            }

            Console.WriteLine($"- {name}");
            builder.AppendLine();
            builder.AppendLine(generated);
        }

        Console.WriteLine();
        Console.WriteLine($"> Functions: {ast.Functions.Count}");
        foreach (var function in ast.Functions)
        {
            if (!ShouldGenerate(function.Span))
            {
                continue;
            }

            var name = GenerateFunction(function, out var generated);
            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(generated))
            {
                continue;
            }

            Console.WriteLine($"- {name}");
            builder.AppendLine();
            builder.AppendLine(generated);
        }

        builder.AppendLine("}");

        Console.WriteLine();
        Console.WriteLine($"> Enums: {ast.Enums.Count}");
        foreach (var cppEnum in ast.Enums)
        {
            if (!ShouldGenerate(cppEnum.Span))
            {
                continue;
            }

            var name = GenerateEnum(cppEnum, out var generated);
            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(generated))
            {
                continue;
            }

            types.Add(name);
            generated = "namespace " + options.GeneratedNamespace + ";\n\n" + generated;
            generated = Header + "\n" + generated;
            var path = $"{options.OutputPath}/Enums/{name}.cs";
            Console.WriteLine($"- Generated: {name} - {path}");
            WriteFile(path, generated);
        }

        Console.WriteLine();
        Console.WriteLine($"> Structs: {ast.Classes.Count}");
        foreach (var cppStruct in ast.Classes)
        {
            if (!ShouldGenerate(cppStruct.Span))
            {
                continue;
            }

            var name = GenerateStruct(cppStruct, out var generated);
            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(generated))
            {
                continue;
            }

            types.Add(name);
            var generate = "";
            generate += Header + "\n";
            generate += "using System.Runtime.InteropServices;\n";
            generate += "using Bindgen.Interop;\n";

            foreach (var import in options.ExistingTypes.Values.Distinct())
            {
                generate += "using " + import + ";\n";
            }

            generate += "\nnamespace " + options.GeneratedNamespace + ";\n\n";
            generate += generated;
            var path = $"{options.OutputPath}/Types/{name}.cs";
            Console.WriteLine($"- Generated: {name} - {path}");
            WriteFile(path, generate);
        }

        var outPath = $"{options.OutputPath}/{options.GeneratedClass}.cs";
        Console.WriteLine($"> Generated: {options.GeneratedClass} - {outPath}");
        WriteFile(outPath, builder.ToString());

        outPath = $"{options.OutputPath}/Interop.cs";
        Console.WriteLine($"> Generated: Interop - {outPath}");
        WriteFile(outPath, Header + "\n" + Interop.Generate());

        if (!string.IsNullOrEmpty(options.TestPath))
        {
            outPath = $"{options.TestPath}/Test.cs";
            Console.WriteLine($"> Generated: Test - {outPath}");
            WriteFile(outPath, Header + "\n" + Test.Generate());

            var testBuilder = new StringBuilder();
            testBuilder.AppendLine(Header);
            testBuilder.AppendLine("using Xunit;");
            testBuilder.AppendLine("using Bindgen.Test;");
            testBuilder.AppendLine();
            testBuilder.AppendLine($"namespace {options.GeneratedNamespace}.Test;");
            testBuilder.AppendLine();
            testBuilder.AppendLine($"public class {options.GeneratedClass}Test");
            testBuilder.AppendLine("{");

            testBuilder.Append(
                $$"""
                    private unsafe void CheckType<T>() where T : unmanaged
                    {
                        Assert.True(BlittableHelper.IsBlittable<T>());
                    }
                """
            );

            testBuilder.AppendLine();
            testBuilder.AppendLine();
            testBuilder.AppendLine("    [Fact]");
            testBuilder.AppendLine("    public void CheckTypes()");
            testBuilder.AppendLine("    {");

            foreach (var type in types)
            {
                testBuilder.AppendLine($"        CheckType<{type}>();");
            }

            testBuilder.AppendLine("    }");
            testBuilder.AppendLine("}");

            outPath = $"{options.TestPath}/{options.GeneratedClass}Test.cs";
            Console.WriteLine($"> Generated: {options.GeneratedClass}Test - {outPath}");
            WriteFile(outPath, testBuilder.ToString());
        }
    }

    private string GenerateConstant(CppMacro macro, out string output)
    {
        string name = macro.Name.Trim();
        string value = macro.Value.Trim();

        output = "";

        if (string.IsNullOrEmpty(value))
        {
            return name;
        }

        if (value.StartsWith("0x"))
        {
            output += $"    public const int {name} = {Convert.ToInt32(value, 16)};";
        }
        else if (int.TryParse(value, out _))
        {
            output += $"    public const int {name} = {value};";
        }
        else if (float.TryParse(value.TrimEnd('f'), out _))
        {
            output += $"    public const float {name} = {value.TrimEnd('f')}f;";
        }
        else if (value.StartsWith("\""))
        {
            output += $"    public const string {name} = \"{value.Replace("\"", "")}\";";
        }
        else if (value.Contains("/"))
        {
            output += $"    public static readonly float {name} = {value};";
        }
        else if (value.StartsWith("CLITERAL("))
        {
            string re = "CLITERAL\\((.*)\\)";
            var match = Regex.Match(value, re);
            var type = match.Groups[1].Value;
            var typeValue = value.Substring(match.Length + 1, value.Length - match.Length - 2);

            if (!literalValues.ContainsKey(type))
            {
                literalValues.Add(type, new());
            }

            literalValues[type][name] = typeValue;
        }
        else
        {
            Console.WriteLine($"- Unsupported macro: {name} = {value}");
        }

        return name;
    }

    private string GenerateEnum(CppEnum cppEnum, out string output)
    {
        string enumName = MapType(cppEnum.Name, cppEnum.Name, cppEnum.Name);

        output = "";
        output += $"public enum {enumName}\n";
        output += "{\n";

        foreach (var enumItem in cppEnum.Items)
        {
            GenerateComments(enumItem, ref output);

            string itemName = enumItem.Name;
            string itemValue = enumItem.ValueExpression?.ToString() ?? "";

            if (string.IsNullOrEmpty(itemValue))
            {
                output += $"    {itemName},\n";
            }
            else
            {
                output += $"    {itemName} = {itemValue},\n";
            }
        }

        output += "}";
        return enumName;
    }

    private string GenerateStruct(CppClass cppStruct, out string output)
    {
        string structName = MapType(cppStruct.Name, cppStruct.Name, cppStruct.Name);

        output = "";

        if (options.ExistingTypes.ContainsKey(structName))
        {
            return "";
        }

        output += "[StructLayout(LayoutKind.Sequential)]\n";
        output += $"public partial struct {structName}\n";
        output += "{\n";

        // Generate constants
        if (literalValues.TryGetValue(structName, out var values))
        {
            foreach (var value in values)
            {
                var name = value.Key;
                var type = value.Value;
                output += $"    public static readonly {structName} {name} = new {structName}({type});\n";
            }

            output += "\n";
        }

        var generateConstructor = cppStruct.Fields.Count > 0;

        // Generate fields
        foreach (var field in cppStruct.Fields)
        {
            GenerateComments(field, ref output);

            var pointerCount = 0;
            string fieldType = ConvertCppTypeToCSharp(
                structName,
                field.Name,
                field.Type,
                ref pointerCount,
                out var arraySize
            );
            string fieldName = MapName(field.Name, toPascalCase: true);

            if (arraySize > 0)
            {
                generateConstructor = false;

                if (IsNotPrimitive(fieldType))
                {
                    for (int i = 0; i < arraySize; i++)
                    {
                        output += $"    public {fieldType} {fieldName}{i};\n";
                    }
                }
                else
                {
                    output += $"    public unsafe fixed {fieldType} {fieldName}[{arraySize}];\n";
                }
            }
            else
            {
                if (pointerCount > 0)
                {
                    output += $"    public unsafe {fieldType}{new string('*', pointerCount)} {fieldName};\n";
                }
                else
                {
                    output += $"    public {fieldType} {fieldName};\n";
                }
            }
        }

        // Generate constructor
        if (generateConstructor)
        {
            var constructorOutput = "";
            bool first = true;
            bool unsafeDecl = false;
            foreach (var field in cppStruct.Fields)
            {
                var pointerCount = 0;
                string fieldType = ConvertCppTypeToCSharp(
                    structName,
                    field.Name,
                    field.Type,
                    ref pointerCount,
                    out var arraySize
                );
                string fieldName = MapName(field.Name, toCamelCase: true);

                if (!first)
                {
                    constructorOutput += ", ";
                }
                first = false;

                constructorOutput += $"{fieldType}{new string('*', pointerCount)} {fieldName}";

                if (pointerCount > 0)
                {
                    unsafeDecl = true;
                }
            }

            constructorOutput =
                "\n    public " + (unsafeDecl ? "unsafe " : "") + structName + "(" + constructorOutput + ")\n    {\n";
            output += constructorOutput;

            foreach (var field in cppStruct.Fields)
            {
                string fieldName = MapName(field.Name, toPascalCase: true);
                output += $"        this.{fieldName} = {ToCamelCase(fieldName)};\n";
            }
            output += "    }\n";
        }

        output += "}";
        return structName;
    }

    private string GenerateFunction(CppFunction function, out string output)
    {
        var pointerCount = 0;
        string returnType = ConvertCppTypeToCSharp(
            function.Name,
            "return",
            function.ReturnType,
            ref pointerCount,
            out _
        );
        returnType = AppendPointer(returnType, pointerCount);

        string functionName = MapName(function.Name);
        List<string> parameters = new List<string>();
        bool isUnsafe = pointerCount > 0;

        foreach (var parameter in function.Parameters)
        {
            var paramPointerCount = 0;
            string paramType = ConvertCppTypeToCSharp(
                functionName,
                parameter.Name,
                parameter.Type,
                ref paramPointerCount,
                out _
            );
            string paramName = MapName(parameter.Name);
            bool isArray = options.DetectArray(function.Name, parameter.Name);

            if (paramPointerCount > 0)
            {
                if (paramPointerCount == 1 && IsSimpleRef(function, paramName, paramType) && !isArray)
                {
                    paramType = "ref " + paramType;
                }
                else
                {
                    isUnsafe = true;
                    paramType = AppendPointer(paramType, paramPointerCount);
                }
            }

            parameters.Add($"{paramType} {paramName}");
        }

        if (function.Flags.HasFlag(CppFunctionFlags.Variadic))
        {
            // FIXME: Use something real for varargs
            // https://github.com/dotnet/runtime/issues/48796
            parameters.Add("IntPtr args");
        }

        string parametersString = string.Join(", ", parameters);

        output = "";
        GenerateComments(function, ref output);

        if (functionName != function.Name)
        {
            output +=
                $"    [LibraryImport(LIBRARY, EntryPoint = \"{function.Name}\", StringMarshalling = StringMarshalling.Utf8)]\n";
        }
        else
        {
            output += $"    [LibraryImport(LIBRARY, StringMarshalling = StringMarshalling.Utf8)]\n";
        }

        output += "    [UnmanagedCallConv(CallConvs = [typeof(CallConvCdecl)])]\n";
        output +=
            $"    public static {(isUnsafe ? "unsafe " : "")}partial {returnType} {functionName}({parametersString});";

        return functionName;
    }

    private bool GenerateComments(CppDeclaration dec, ref string output)
    {
        var lines = fileContent.Split('\n');
        var comments = new List<string>();
        var startLine = dec.Span.Start.Line - 1 - options.Includes.Count();
        var endLine = dec.Span.End.Line - options.Includes.Count();

        if (dec.Span.Start.File == "cppast.input")
        {
            for (int i = startLine; i < endLine; i++)
            {
                var line = lines[i].Trim();
                if (line.Contains("//"))
                {
                    comments.Add(line.Substring(line.IndexOf("//") + 2).Trim());
                }
            }
        }

        var commentsString = string.Join("\n", comments);

        if (string.IsNullOrEmpty(commentsString))
        {
            var commentList = dec.Comment?.ToString().Split('\n').Select(c => c.Trim().Replace("/", ""));
            if (commentList != null)
            {
                commentsString = string.Join("\n    /// ", commentList);
            }
        }

        if (!string.IsNullOrEmpty(commentsString))
        {
            output += $"    /// <summary>\n";
            output += $"    /// {commentsString.Replace("<", "&lt;").Replace(">", "&gt;")}\n";
            output += $"    /// </summary>\n";
            return true;
        }

        return false;
    }

    private string ConvertCppTypeToCSharp(
        string parent,
        string cppName,
        CppType cppType,
        ref int pointerCount,
        out int arraySize,
        bool skipHighOrder = false
    )
    {
        arraySize = 0;
        switch (cppType)
        {
            case CppPrimitiveType primitiveType:
                return MapType(
                    parent,
                    cppName,
                    primitiveType.Kind switch
                    {
                        CppPrimitiveKind.Void => "void",
                        CppPrimitiveKind.Bool => skipHighOrder ? "sbyte" : "NativeBool",
                        CppPrimitiveKind.Char => "sbyte",
                        CppPrimitiveKind.Short => "short",
                        CppPrimitiveKind.Int => "int",
                        CppPrimitiveKind.Long => "long",
                        CppPrimitiveKind.Float => "float",
                        CppPrimitiveKind.Double => "double",
                        CppPrimitiveKind.UnsignedChar => "byte",
                        CppPrimitiveKind.UnsignedShort => "ushort",
                        CppPrimitiveKind.UnsignedInt => "uint",
                        CppPrimitiveKind.UnsignedLong => "ulong",
                        _ => throw new NotSupportedException($"Unsupported primitive type: {primitiveType.Kind}"),
                    }
                );
            case CppPointerType pointerType:
                if (pointerCount == 0 && !skipHighOrder)
                {
                    if (pointerType.ElementType is CppPrimitiveType pt)
                    {
                        if (pt.Kind == CppPrimitiveKind.Char)
                        {
                            return "string";
                        }
                    }
                    else if (pointerType.ElementType is CppQualifiedType qt)
                    {
                        if (qt.ElementType is CppPrimitiveType ptt)
                        {
                            if (ptt.Kind == CppPrimitiveKind.Char)
                            {
                                return "string";
                            }
                        }
                    }
                }

                pointerCount++;
                return ConvertCppTypeToCSharp(
                    parent,
                    cppName,
                    pointerType.ElementType,
                    ref pointerCount,
                    out _,
                    skipHighOrder
                );
            case CppReferenceType referenceType:
                pointerCount++;
                return ConvertCppTypeToCSharp(
                    parent,
                    cppName,
                    referenceType.ElementType,
                    ref pointerCount,
                    out _,
                    skipHighOrder
                );
            case CppArrayType arrayType:
                arraySize = arrayType.Size;
                return ConvertCppTypeToCSharp(
                    parent,
                    cppName,
                    arrayType.ElementType,
                    ref pointerCount,
                    out _,
                    skipHighOrder
                );
            case CppQualifiedType qualifiedType:
                return ConvertCppTypeToCSharp(
                    parent,
                    cppName,
                    qualifiedType.ElementType,
                    ref pointerCount,
                    out _,
                    skipHighOrder
                );
            case CppTypedef typedefType:
                return ConvertCppTypeToCSharp(
                    parent,
                    cppName,
                    typedefType.ElementType,
                    ref pointerCount,
                    out _,
                    skipHighOrder
                );
            case CppClass cppClass:
                return MapType(parent, cppName, cppClass.Name);
            case CppEnum cppEnum:
                return MapType(parent, cppName, cppEnum.Name);
            case CppFunctionType cppFunctionType:
                var returnPointerCount = 0;
                string returnType = ConvertCppTypeToCSharp(
                    cppName,
                    "return",
                    cppFunctionType.ReturnType,
                    ref returnPointerCount,
                    out _,
                    true
                );
                returnType = AppendPointer(returnType, returnPointerCount);

                List<string> parameters = new List<string>();
                foreach (var parameter in cppFunctionType.Parameters)
                {
                    var paramPointerCount = 0;
                    string paramType = ConvertCppTypeToCSharp(
                        cppName,
                        parameter.Name,
                        parameter.Type,
                        ref paramPointerCount,
                        out _,
                        true
                    );
                    paramType = AppendPointer(paramType, paramPointerCount);
                    parameters.Add(paramType);
                }

                string parametersString = string.Join(", ", parameters);
                return $"delegate unmanaged[Cdecl]<{parametersString}, {returnType}>";
            default:
                throw new NotSupportedException($"Unsupported type: {cppType.GetType().Name}");
        }
    }

    private string MapName(string name, bool toPascalCase = false, bool toCamelCase = false)
    {
        var o = options.TransformName(name) ?? name;
        o =
            toCamelCase ? ToCamelCase(o)
            : toPascalCase ? ToPascalCase(o)
            : o;

        if (reservedKeywords.Contains(o))
        {
            return "@" + o;
        }

        return o;
    }

    private string MapType(string parent, string name, string type)
    {
        return type switch
        {
            "int32_t" => "int",
            "uint32_t" => "uint",
            "int16_t" => "short",
            "uint16_t" => "ushort",
            "int8_t" => "sbyte",
            "uint8_t" => "byte",
            "int64_t" => "long",
            "uint64_t" => "ulong",
            _ => options.TransformType(parent, name, type) ?? type,
        };
    }

    private bool ShouldGenerate(CppSourceSpan span)
    {
        foreach (var include in options.GenerateIncludes)
        {
            if (span.Start.File.Contains(include))
            {
                return true;
            }
        }

        return span.Start.File == "cppast.input";
    }

    private static string AppendPointer(string type, int pointerCount)
    {
        if (type.Contains("delegate"))
        {
            return type.Replace("delegate", "delegate" + new string('*', pointerCount));
        }

        return type + new string('*', pointerCount);
    }

    private static bool IsNotPrimitive(string identifier)
    {
        return identifier[0].ToString().ToLower() != identifier[0].ToString();
    }

    private static bool IsSimpleRef(CppFunction fn, string name, string type)
    {
        if (type.Contains("void") || type.Contains("delegate") || type == "byte")
        {
            return false;
        }

        var baseName = name.EndsWith("s") ? name.Substring(0, name.Length - 1) : name;
        var possibleSuffixes = new List<string>
        {
            "Count",
            "sCount",
            "Length",
            "sLength",
            "Size",
            "sSize",
            "Len",
            "sLen",
        };

        var found = false;

        foreach (var p in fn.Parameters)
        {
            if (p.Name == name)
            {
                found = true;
                continue;
            }

            foreach (var suffix in possibleSuffixes)
            {
                if (found && (p.Name == baseName + suffix || p.Name == suffix.ToLower()))
                {
                    return false; // It's an array
                }
            }
        }

        return true; // It's not an array
    }

    private static string ToPascalCase(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return value;
        }

        return char.ToUpper(value[0]) + value.Substring(1);
    }

    private static string ToCamelCase(string value)
    {
        if (string.IsNullOrEmpty(value))
        {
            return value;
        }

        return char.ToLower(value[0]) + value.Substring(1);
    }

    private static void WriteFile(string path, string content)
    {
        var directoryPath = Path.GetDirectoryName(path);
        if (!string.IsNullOrEmpty(directoryPath))
        {
            Directory.CreateDirectory(directoryPath);
        }

        File.WriteAllText(path, content);
    }
}
